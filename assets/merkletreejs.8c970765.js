import{c as e,g as t}from"./react.49c1050d.js";import{b as r}from"./buffer-reverse.f714979d.js";import{c as s,s as i}from"./crypto-js.ce164af7.js";import{t as f}from"./treeify.84ad14c1.js";var h={},n={},o={},a=e&&e.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(o,"__esModule",{value:!0}),o.Base=void 0;const u=a(s.exports);class l{print(){l.print(this)}_bufferIndexOf(e,t){for(let r=0;r<e.length;r++)if(t.equals(e[r]))return r;return-1}static bufferify(e){if(!Buffer.isBuffer(e)){if("object"==typeof e&&e.words)return Buffer.from(e.toString(u.default.enc.Hex),"hex");if(l.isHexString(e))return Buffer.from(e.replace(/^0x/,""),"hex");if("string"==typeof e)return Buffer.from(e);if("number"==typeof e){let t=e.toString();return t.length%2&&(t=`0${t}`),Buffer.from(t,"hex")}if(ArrayBuffer.isView(e))return Buffer.from(e.buffer,e.byteOffset,e.byteLength)}return e}static isHexString(e){return"string"==typeof e&&/^(0x)?[0-9A-Fa-f]*$/.test(e)}static print(e){console.log(e.toString())}bufferToHex(e,t=!0){return l.bufferToHex(e,t)}static bufferToHex(e,t=!0){return`${t?"0x":""}${(e||Buffer.alloc(0)).toString("hex")}`}bufferify(e){return l.bufferify(e)}bufferifyFn(e){return t=>{const r=e(t);return Buffer.isBuffer(r)?r:this._isHexString(r)?Buffer.from(r.replace("0x",""),"hex"):"string"==typeof r?Buffer.from(r):ArrayBuffer.isView(r)?Buffer.from(r.buffer,r.byteOffset,r.byteLength):Buffer.from(e(u.default.enc.Hex.parse(t.toString("hex"))).toString(u.default.enc.Hex),"hex")}}_isHexString(e){return l.isHexString(e)}_log2(e){return 1===e?0:1+this._log2(e/2|0)}_zip(e,t){return e.map(((e,r)=>[e,t[r]]))}}o.Base=l,o.default=l;var c=e&&e.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.MerkleTree=void 0;const g=c(r),p=c(i.exports),d=c(o),y=c(f.exports);class b extends d.default{constructor(e,t=p.default,r={}){if(super(),this.duplicateOdd=!1,this.hashLeaves=!1,this.isBitcoinTree=!1,this.leaves=[],this.layers=[],this.sortLeaves=!1,this.sortPairs=!1,this.sort=!1,this.fillDefaultHash=null,this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,r.fillDefaultHash)if("function"==typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else{if(!Buffer.isBuffer(r.fillDefaultHash)&&"string"!=typeof r.fillDefaultHash)throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.fillDefaultHash=(e,t)=>r.fillDefaultHash}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(Buffer.compare)),this.fillDefaultHash)for(let t=0;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)t>=this.leaves.length&&this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.layers=[this.leaves],this._createHashes(this.leaves)}_createHashes(e){for(;e.length>1;){const t=this.layers.length;this.layers.push([]);for(let r=0;r<e.length;r+=2){if(r+1===e.length&&e.length%2==1){let s=e[e.length-1],i=s;if(this.isBitcoinTree){s=Buffer.concat([g.default(s),g.default(s)]),i=this.hashFn(s),i=g.default(this.hashFn(i)),this.layers[t].push(i);continue}if(!this.duplicateOdd){this.layers[t].push(e[r]);continue}}const s=e[r],i=r+1===e.length?s:e[r+1];let f=null,h=null;h=this.isBitcoinTree?[g.default(s),g.default(i)]:[s,i],this.sortPairs&&h.sort(Buffer.compare),f=Buffer.concat(h);let n=this.hashFn(f);this.isBitcoinTree&&(n=g.default(this.hashFn(n))),this.layers[t].push(n)}e=this.layers[t]}}addLeaf(e,t=!1){t&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e,t=!1){t&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(Buffer.compare))),this.leaves.filter((t=>-1!==this._bufferIndexOf(e,t)))):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);const t=this.getLeaves();for(let r=0;r<t.length;r++){if(t[r].equals(e))return r}return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map((e=>this.bufferToHex(e)))}static marshalLeaves(e){return JSON.stringify(e.map((e=>b.bufferToHex(e))),null,2)}static unmarshalLeaves(e){let t=null;if("string"==typeof e)t=JSON.parse(e);else{if(!(e instanceof Object))throw new Error("Expected type of string or object");t=e}if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(b.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce(((e,t)=>(Array.isArray(t)?e.push(t.map((e=>this.bufferToHex(e)))):e.push(t),e)),[])}getLayersFlat(){const e=this.layers.reduce(((e,t)=>(Array.isArray(t)?e.unshift(...t):e.unshift(t),e)),[]);return e.unshift(Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map((e=>this.bufferToHex(e)))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?Buffer.from([]):this.layers[this.layers.length-1][0]||Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if(void 0===e)throw new Error("leaf is required");e=this.bufferify(e);const r=[];if(!Number.isInteger(t)){t=-1;for(let r=0;r<this.leaves.length;r++)0===Buffer.compare(e,this.leaves[r])&&(t=r)}if(t<=-1)return[];for(let s=0;s<this.layers.length;s++){const e=this.layers[s],i=t%2,f=i?t-1:this.isBitcoinTree&&t===e.length-1&&s<this.layers.length-1?t:t+1;f<e.length&&r.push({position:i?"left":"right",data:e[f]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map((e=>this.bufferToHex(e.data)))}getPositionalHexProof(e,t){return this.getProof(e,t).map((e=>["left"===e.position?0:1,this.bufferToHex(e.data)]))}static marshalProof(e){const t=e.map((e=>"string"==typeof e?e:Buffer.isBuffer(e)?b.bufferToHex(e):{position:e.position,data:b.bufferToHex(e.data)}));return JSON.stringify(t,null,2)}static unmarshalProof(e){let t=null;if("string"==typeof e)t=JSON.parse(e);else{if(!(e instanceof Object))throw new Error("Expected type of string or object");t=e}if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map((e=>{if("string"==typeof e)return b.bufferify(e);if(e instanceof Object)return{position:e.position,data:b.bufferify(e.data)};throw new Error("Expected item to be of type string or object")}))}getProofIndices(e,t){const r=Math.pow(2,t);let s=new Set;for(const o of e){let e=r+o;for(;e>1;)s.add(1^e),e=e/2|0}const i=e.map((e=>r+e)),f=Array.from(s).sort(((e,t)=>e-t)).reverse();s=i.concat(f);const h=new Set,n=[];for(let o of s)if(!h.has(o))for(n.push(o);o>1&&(h.add(o),h.has(1^o));)o=o/2|0;return n.filter((t=>!e.includes(t-r)))}getProofIndicesForUnevenTree(e,t){const r=Math.ceil(Math.log2(t)),s=[];for(let h=0;h<r;h++){t%2!=0&&s.push({index:h,leavesCount:t}),t=Math.ceil(t/2)}const i=[];let f=e;for(let h=0;h<r;h++){let e=f.map((e=>e%2==0?e+1:e-1)).filter((e=>!f.includes(e)));const t=s.find((({index:e})=>e===h));t&&f.includes(t.leavesCount-1)&&(e=e.slice(0,-1)),i.push(e),f=[...new Set(f.map((e=>e%2==0?e/2:e%2==0?(e+1)/2:(e-1)/2)))]}return i}getMultiProof(e,t){t||(t=e,e=this.getLayersFlat());if(this.isUnevenTree()&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let e=t;this.sortPairs&&(e=e.sort(Buffer.compare));let r=e.map((e=>this._bufferIndexOf(this.leaves,e))).sort(((e,t)=>e===t?0:e>t?1:-1));if(!r.every((e=>-1!==e)))throw new Error("Element does not exist in Merkle tree");const s=[],i=[];let f=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];for(let t=0;t<r.length;t++){const h=r[t],n=this._getPairNode(e,h);s.push(e[h]),n&&i.push(n),f.push(h/2|0)}r=f.filter(((e,t,r)=>r.indexOf(e)===t)),f=[]}return i.filter((e=>!s.includes(e)))}return this.getProofIndices(t,this._log2(e.length/2|0)).map((t=>e[t]))}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],s=t;for(const i of e){const e=[];for(const r of s){if(r%2==0){const t=r+1;if(!s.includes(t)&&i[t]){e.push(i[t]);continue}}const t=r-1;s.includes(t)||!i[t]||e.push(i[t])}r=r.concat(e);const t=new Set;for(const r of s)r%2!=0?r%2!=0?t.add((r-1)/2):t.add((r+1)/2):t.add(r/2);s=Array.from(t)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map((e=>this.bufferToHex(e)))}getProofFlags(e,t){if(!Array.isArray(e)||e.length<=0)throw new Error("Invalid Inputs!");let r;if(r=e.every(Number.isInteger)?e.sort(((e,t)=>e===t?0:e>t?1:-1)):e.map((e=>this._bufferIndexOf(this.leaves,e))).sort(((e,t)=>e===t?0:e>t?1:-1)),!r.every((e=>-1!==e)))throw new Error("Element does not exist in Merkle tree");const s=t.map((e=>this.bufferify(e))),i=[],f=[];for(let h=0;h<this.layers.length;h++){const e=this.layers[h];r=r.reduce(((t,r)=>{if(!i.includes(e[r])){const t=this._getPairNode(e,r),h=s.includes(e[r])||s.includes(t);t&&f.push(!h),i.push(e[r]),i.push(t)}return t.push(r/2|0),t}),[])}return f}verify(e,t,r){let s=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let i=0;i<e.length;i++){const t=e[i];let r=null,f=null;if("string"==typeof t)r=this.bufferify(t),f=!0;else if(Array.isArray(t))f=0===t[0],r=this.bufferify(t[1]);else if(Buffer.isBuffer(t))r=t,f=!0;else{if(!(t instanceof Object))throw new Error("Expected node to be of type string or object");r=this.bufferify(t.data),f="left"===t.position}const h=[];this.isBitcoinTree?(h.push(g.default(s)),h[f?"unshift":"push"](g.default(r)),s=this.hashFn(Buffer.concat(h)),s=g.default(this.hashFn(s))):this.sortPairs?-1===Buffer.compare(s,r)?(h.push(s,r),s=this.hashFn(Buffer.concat(h))):(h.push(r,s),s=this.hashFn(Buffer.concat(h))):(h.push(s),h[f?"unshift":"push"](r),s=this.hashFn(Buffer.concat(h)))}return 0===Buffer.compare(s,r)}verifyMultiProof(e,t,r,s,i){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(e,t,r,s,i);const f=Math.ceil(Math.log2(s));e=this.bufferify(e),r=r.map((e=>this.bufferify(e))),i=i.map((e=>this.bufferify(e)));const h={};for(const[a,u]of this._zip(t,r))h[Math.pow(2,f)+a]=u;for(const[a,u]of this._zip(this.getProofIndices(t,f),i))h[a]=u;let n=Object.keys(h).map((e=>+e)).sort(((e,t)=>e-t));n=n.slice(0,n.length-1);let o=0;for(;o<n.length;){const e=n[o];if(e>=2&&{}.hasOwnProperty.call(h,1^e)){let t=[h[e-e%2],h[e-e%2+1]];this.sortPairs&&(t=t.sort(Buffer.compare));const r=t[1]?this.hashFn(Buffer.concat(t)):t[0];h[e/2|0]=r,n.push(e/2|0)}o+=1}return!t.length||{}.hasOwnProperty.call(h,1)&&h[1].equals(e)}verifyMultiProofWithFlags(e,t,r,s){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);const i=t.length,f=s.length,h=[];let n=0,o=0,a=0;for(let u=0;u<f;u++){const e=[s[u]?n<i?t[n++]:h[o++]:r[a++],n<i?t[n++]:h[o++]].sort(Buffer.compare);h[u]=this.hashFn(Buffer.concat(e))}return 0===Buffer.compare(h[f-1],e)}verifyMultiProofForUnevenTree(e,t,r,s,i){e=this.bufferify(e),r=r.map((e=>this.bufferify(e))),i=i.map((e=>this.bufferify(e)));const f=this.calculateRootForUnevenTree(t,r,s,i);return e.equals(f)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const e=this.getLayers().map((e=>e.map((e=>this.bufferToHex(e,!1))))),t=[];for(let r=0;r<e.length;r++){const s=[];for(let i=0;i<e[r].length;i++){const f={[e[r][i]]:null};if(t.length){f[e[r][i]]={};const s=t.shift(),h=Object.keys(s)[0];if(f[e[r][i]][h]=s[h],t.length){const s=t.shift(),h=Object.keys(s)[0];f[e[r][i]][h]=s[h]}}s.push(f)}t.push(...s)}return t[0]}static verify(e,t,r,s=p.default,i={}){return new b([],s,i).verify(e,t,r)}static getMultiProof(e,t){return new b([]).getMultiProof(e,t)}resetTree(){this.leaves=[],this.layers=[]}_getPairNode(e,t){const r=t%2==0?t+1:t-1;return r<e.length?e[r]:null}_toTreeString(){const e=this.getLayersAsObject();return y.default.asTree(e,!0)}toString(){return this._toTreeString()}isUnevenTree(e){const t=(null==e?void 0:e.length)||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,r,s){const i=this._zip(e,t).sort((([e],[t])=>e-t)),f=i.map((([e])=>e)),h=this.getProofIndicesForUnevenTree(f,r);let n=0;const o=[];for(let u=0;u<h.length;u++){const e=h[u],t=n;n+=e.length,o[u]=this._zip(e,s.slice(t,n))}const a=[i];for(let u=0;u<o.length;u++){const e=o[u].concat(a[u]).sort((([e],[t])=>e-t)).map((([,e])=>e)),t=a[u].map((([e])=>e)),r=[...new Set(t.map((e=>e%2==0?e/2:e%2==0?(e+1)/2:(e-1)/2)))],s=[];for(let i=0;i<r.length;i++){const t=r[i],f=e[2*i],h=e[2*i+1],n=h?this.hashFn(Buffer.concat([f,h])):f;s.push([t,n])}a.push(s)}return a[a.length-1][0][1]}}n.MerkleTree=b,"undefined"!=typeof window&&(window.MerkleTree=b),n.default=b;var m={},v=e&&e.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(m,"__esModule",{value:!0}),m.MerkleMountainRange=void 0;const w=v(o),B=v(i.exports);class x extends w.default{constructor(e=B.default,t=[],r,s,i){super(),this.root=Buffer.alloc(0),this.size=0,this.width=0,this.hashes={},this.data={},t=t.map(this.bufferify),this.hashFn=this.bufferifyFn(e),this.hashLeafFn=r,this.peakBaggingFn=s,this.hashBranchFn=i;for(const f of t)this.append(f)}append(e){e=this.bufferify(e);const t=this.hashFn(e),r=this.bufferToHex(t);this.data[r]&&this.bufferToHex(this.hashFn(this.data[r]))===r||(this.data[r]=e);const s=this.hashLeaf(this.size+1,t);this.hashes[this.size+1]=s,this.width+=1;const i=this.getPeakIndexes(this.width);this.size=this.getSize(this.width);const f=[];for(let h=0;h<i.length;h++)f[h]=this._getOrCreateNode(i[h]);this.root=this.peakBagging(this.width,f)}hashLeaf(e,t){return t=this.bufferify(t),this.hashLeafFn?this.bufferify(this.hashLeafFn(e,t)):this.hashFn(Buffer.concat([this.bufferify(e),t]))}hashBranch(e,t,r){return this.hashBranchFn?this.bufferify(this.hashBranchFn(e,t,r)):this.hashFn(Buffer.concat([this.bufferify(e),this.bufferify(t),this.bufferify(r)]))}getPeaks(){const e=this.getPeakIndexes(this.width),t=[];for(let r=0;r<e.length;r++)t[r]=this.hashes[e[r]];return t}getLeafIndex(e){return e%2==1?this.getSize(e):this.getSize(e-1)+1}getPeakIndexes(e){const t=this.numOfPeaks(e),r=[];let s=0,i=0;for(let f=255;f>0&&!(0!=(e&1<<f-1)&&(i=i+(1<<f)-1,r[s++]=i,r.length>=t));f--);if(s!==r.length)throw new Error("invalid bit calculation");return r}numOfPeaks(e){let t=e,r=0;for(;t>0;)t%2==1&&r++,t>>=1;return r}peakBagging(e,t){const r=this.getSize(e);if(this.numOfPeaks(e)!==t.length)throw new Error("received invalid number of peaks");return 0!==e||t.length?this.peakBaggingFn?this.bufferify(this.peakBaggingFn(r,t)):this.hashFn(Buffer.concat([this.bufferify(r),...t.map(this.bufferify)])):Buffer.alloc(0)}getSize(e){return(e<<1)-this.numOfPeaks(e)}getRoot(){return this.root}getHexRoot(){return this.bufferToHex(this.getRoot())}getNode(e){return this.hashes[e]}mountainHeight(e){let t=1;for(;1<<t<=e+t;)t++;return t-1}heightAt(e){let t=e,r=0,s=0;for(;t>r;)t-=(1<<s)-1,s=this.mountainHeight(t),r=(1<<s)-1;return s-(r-t)}isLeaf(e){return 1===this.heightAt(e)}getChildren(e){const t=e-(1<<this.heightAt(e)-1),r=e-1;if(t===r)throw new Error("not a parent");return[t,r]}getMerkleProof(e){if(e>this.size)throw new Error("out of range");if(!this.isLeaf(e))throw new Error("not a leaf");const t=this.root,r=this.width,s=this.getPeakIndexes(this.width),i=[];let f=0;for(let u=0;u<s.length;u++)i[u]=this.hashes[s[u]],s[u]>=e&&0===f&&(f=s[u]);let h=0,n=0,o=this.heightAt(f);const a=[];for(;f!==e;)o--,[h,n]=this.getChildren(f),f=e<=h?h:n,a[o-1]=this.hashes[e<=h?n:h];return{root:t,width:r,peakBagging:i,siblings:a}}verify(e,t,r,s,i,f){s=this.bufferify(s);if(this.getSize(t)<r)throw new Error("index is out of range");if(!e.equals(this.peakBagging(t,i)))throw new Error("invalid root hash from the peaks");let h,n=0;const o=this.getPeakIndexes(t);for(let p=0;p<o.length;p++)if(o[p]>=r){h=i[p],n=o[p];break}if(!h)throw new Error("target not found");let a=f.length+1;const u=new Array(a);let l,c=0,g=0;for(;a>0&&(u[--a]=n,n!==r);)[c,g]=this.getChildren(n),n=r>c?g:c;for(;a<u.length;)n=u[a],l=0===a?this.hashLeaf(n,this.hashFn(s)):n-1===u[a-1]?this.hashBranch(n,f[a-1],l):this.hashBranch(n,l,f[a-1]),a++;if(!l.equals(h))throw new Error("hashed peak is invalid");return!0}peaksToPeakMap(e,t){const r={};let s=0,i=0,f=t.length;for(let h=1;h<=32;h++)s=32-h,i=1<<h-1,r[s]=0!=(e&i)?t[--f]:0;if(0!==f)throw new Error("invalid number of peaks");return r}peakMapToPeaks(e,t){const r=this.numOfPeaks(e),s=new Array(r);let i=0;for(let f=0;f<32;f++)0!==t[f]&&(s[i++]=t[f]);if(i!==r)throw new Error("invalid number of peaks");return s}peakUpdate(e,t,r){const s={},i=e+1;let f=this.getLeafIndex(i),h=this.hashLeaf(f,r),n=0,o=0,a=!1,u=!1,l=!1;for(let c=1;c<=32;c++)n=32-c,l?s[n]=t[n]:(o=1<<c-1,a=0!=(e&o),u=0!=(i&o),f++,a&&(h=this.hashBranch(f,t[n],h)),u?(s[n]=a?t[n]:h,l=!0):s[n]=0);return s}rollUp(e,t,r,s){if(!e.equals(this.peakBagging(t,r)))throw new Error("invalid root hash from the peaks");let i=t,f=this.peaksToPeakMap(t,r);for(let h=0;h<s.length;h++)f=this.peakUpdate(i,f,s[h]),i++;return this.peakBagging(i,this.peakMapToPeaks(i,f))}_getOrCreateNode(e){if(e>this.size)throw new Error("out of range");if(!this.hashes[e]){const[t,r]=this.getChildren(e),s=this._getOrCreateNode(t),i=this._getOrCreateNode(r);this.hashes[e]=this.hashBranch(e,s,i)}return this.hashes[e]}}m.MerkleMountainRange=x,m.default=x,function(t){var r=e&&e.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.MerkleTree=void 0;const s=r(n);t.MerkleTree=s.default;var i=m;Object.defineProperty(t,"MerkleMountainRange",{enumerable:!0,get:function(){return i.MerkleMountainRange}}),t.default=s.default}(h);var P=t(h);export{P as l};
